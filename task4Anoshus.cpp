"Stopwatch"

Мне часто хочется измерить время работы/количество вызовов/(суммарное время работы за несколько вызовов) какой-то функции

На данный момент я умею это делать так:


#include <chrono>

unsigned long long get_nanoseconds(){
    static auto t_0 = std::chrono::steady_clock::now();
    return std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - t_0).count();
}

size_t counter_1 = 0;

unsigned long long t_func = 0;
void func(){
    ++counter_1;
    unsigned long long t_0 = get_nanoseconds();

    ... // код самой функции

    t_func += get_nanoseconds() - t_0;
    return;
}

int main(){
    std::ofstream report_file;
    report_file.open ("data/report.txt");  /// какая-то инициализация
    ...

    for (){

        ...  ///функция func, являясь частью алгоритма, вызывается здесь неизвестное заранее количество раз

        unsigned long long t_0 = get_nanoseconds();  ///если мы не можем модифицировать функцию, можно "снаружи" поставить отметки времени
        report_file << some_data << "\n";
        unsigned long long t_1 = get_nanoseconds();

        std::cout << "file_o: " << (t_1 - t_0)/1000 << "\n";
        std::cout << "func: " << t_func/1000 << " " << counter_1 << "\n"; // выводим общее время работы этой функции за итерацию цикла в мкс, количество вызовов
        t_func = 0; counter_1 = 0;                           // зануляем время и количество вызовов
    }
    report_file.close();
    return 0;
}

struct Note{
    std::string name;
    size_t counter;
    unsigned long long time;
}

std::vector<Note> notes;

Для измерения func() потребовалось 7 строчек кода в разных местах проекта, повторяющихся для разных func_1(), func_2(), ...
Также мы создали несколько глобальных переменных.
Поэтому на такие измерения уходит много моего времени.

На самом деле, есть готовые пакеты для профилирования кода, но они по ряду причин не всегда удобны
(например: их можно использовать только для Debug версии, т.е. без оптимизации компилятора. А с оптимизацией отношение времён работы функций меняется)

Чтобы сделать измерение времени удобнее, реализуй класс Stopwatch. Ещё тебе понадобится вспомогательный класс Stopwatch_call.

Потребуется написать и другие мини-классы (struct -ы).

Во всём проекте будет 1 глобальный объект класса Stopwatch, можно назвать его stopwatch.

он(и) должен (и/у)меть:
    >>так:
        stopwatch.note("file_outp");
        report_file << some_data << "\n";
        stopwatch.end();

        что происходит: stopwatch хранит в себе записи вида <строка-имя>, <время>, <счётчик> (мб что-тот ещё??).
        Если запись с данным именем уже есть, измеренное время надо добавлять к этой записи, и увеличить счётчик.

        Заметь, что время вызова самой по себе get_nanoseconds() порядка 2 mcs.
        Значит, накладное время работы stopwatch не должно превышать 1 mcs, иначе класс станет бесполезным из-за ухудшения точности.
        попробуй хранить записи тупо в std::vector<Note>, если это окажется медленно - напиши мне. (Note - твой struct-запись)

    >>так:
    void func(){
        Stopwatch_call call(stopwatch, "measure_1"); ///Тут происходит следущее: call в своём конструкторе хранит указатель на stopwatch
                                                     ///А в деструкторе(который вызывается автоматически при завершении работы функции!!!)
                                                     ///call отправит запрос на создание записи в stopwatch, используя сохранённый указатель
                                                     ///stopwatch создаст новую запись или добавит время работы и +1 к счётчику вызовов
        ... // код самой функции

        return;
    }

    >>выводить все записи:
    std::cout << stopwatch;
    вывод:
    Stopwath measurements:
        measure_1:    13 mcs   n= 1234
        func_2:      140 mcs   n= 12
        file_outp:   1.2 mcs   n= 1
        iter_total:  1.0 sec   n= 1

    (!) Оператор вывода должен также обнулять или стирать все записи в stopwatch.
    формат вывода времени: 1.2/12/123  ns/mcs/ms/sec
    Все записи выровнены по самой длинной строке-названию, с отступом 2 пробела от двоеточия.

///Заметь что таким образом для измерения работы func потребовалось написать 1 строчку.

///Можешь не разбираться с библиотекой <chrono>, хотя желательно. Если не хочешь, просто используй написанную выше get_nanoseconds();

дополонительно:
    >>Поддрежка одновременного проведения нескольких измерений:
        for(...){
            stopwatch.note("iteration");=
            stopwatch.note("f_1");
            f_1();
            stopwatch.end();          
            for (...){  
                stopwatch.note("f_2");
                f_2();
                stopwatch.end();            
            }
            stopwatch.note("f_3");
            f_3();
            stopwatch.end();
            stopwatch.end();
            std::cout << stopwatch;            
        }
    stopwatch.end() работает по принципу стека.
    
    вывод тогда должен выглядеть примерно так:
    
    Stopwath measurements:
        iteration:  1.3 sec   n= 1
        |---f_1:  9.3 mcs   n= 1
        |---f_2:  100 ms    n= 10
        |---f_3:  1.2 sec   n= 1
    
    т.е. должна соблюдаться структура вложенности измерений 
    (в примере вывода мы видим что почти всё время выполнения итерации занимает функция f_3 и можем быть уверены что f_1 и f_2 не нуждаются в оптимизации)

    >>selftest
    Метод для оценки собственного времени работы (а-ля оценка погрешностей)

    >>флаги вывода, регулирующие формат вывода записей.
    Например, выводить только счётчик или только время.

    >>отдельные флаги для каждой записи - чтобы не вызывать get_nanoseconds(), когда мы считаем только количество вызовов.
    тогда вывод может выглядеть так:

    measure_1:       13 mcs   n= 1234
    func_2:          140 mcs   n= 12
    file_outp:       1.2 mcs
    iter_total:      1.0 sec
    math::log_call:  n= 123456   ///я у каждого логарифма поставил stopwatch.note("math::log_call");
